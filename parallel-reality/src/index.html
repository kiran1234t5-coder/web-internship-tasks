<!DOCTYPE html>
<html>
<head>
  <title>Parallel Reality Task Manager</title>

  <!-- React CDN -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <script src="https://unpkg.com/framer-motion/dist/framer-motion.umd.js"></script>

  <style>
    body {
      margin: 0;
      font-family: Arial;
      transition: all 0.5s ease;
    }

    .app {
      padding: 20px;
      min-height: 100vh;
      transition: all 0.5s ease;
    }

    .optimistic {
      background: linear-gradient(45deg, #00ffcc, #00ccff);
      color: black;
    }

    .realistic {
      background: #222;
      color: white;
    }

    .disaster {
      background: linear-gradient(45deg, #660000, #000);
      color: white;
    }

    .task {
      padding: 10px;
      margin: 10px 0;
      border-radius: 8px;
      cursor: grab;
      transition: 0.3s;
    }

    .task.completed {
      text-decoration: line-through;
      opacity: 0.5;
    }

    button {
      margin: 5px;
      padding: 8px 12px;
      border: none;
      cursor: pointer;
      border-radius: 5px;
    }

    input {
      padding: 8px;
      margin: 5px;
    }

    .snapshot-box {
      margin-top: 20px;
      padding: 10px;
      border: 1px solid gray;
    }
  </style>
</head>

<body>
<div id="root"></div>

<script type="text/babel">

const { useState, useEffect, useReducer, useContext, createContext } = React;
const { motion, AnimatePresence } = window["framer-motion"];

// ----------------- REALITY CONTEXT -----------------
const RealityContext = createContext();

function useReality() {
  return useContext(RealityContext);
}

function RealityProvider({ children }) {
  const [mode, setMode] = useState("realistic");

  const randomReality = () => {
    const modes = ["optimistic", "realistic", "disaster"];
    const random = modes[Math.floor(Math.random() * modes.length)];
    setMode(random);
  };

  useEffect(() => {
    randomReality();
  }, []);

  return (
    <RealityContext.Provider value={{ mode, randomReality }}>
      {children}
    </RealityContext.Provider>
  );
}

// ----------------- TASK REDUCER -----------------
function taskReducer(state, action) {
  switch(action.type) {
    case "ADD":
      return [...state, action.payload];

    case "TOGGLE":
      return state.map(task =>
        task.id === action.id ? {...task, completed: !task.completed} : task
      );

    case "DELETE":
      return state.filter(task => task.id !== action.id);

    case "REORDER":
      return action.payload;

    case "SET":
      return action.payload;

    default:
      return state;
  }
}

// ----------------- MAIN APP -----------------
function App() {
  const { mode, randomReality } = useReality();

  const [tasks, dispatch] = useReducer(taskReducer, [], () => {
    return JSON.parse(localStorage.getItem("tasks")) || [];
  });

  const [history, setHistory] = useState([]);
  const [future, setFuture] = useState([]);
  const [snapshots, setSnapshots] = useState([]);

  const [text, setText] = useState("");
  const [dragIndex, setDragIndex] = useState(null);

  // Persist
  useEffect(() => {
    localStorage.setItem("tasks", JSON.stringify(tasks));
  }, [tasks]);

  // Reality Effects
  useEffect(() => {
    if(mode === "optimistic") {
      setTimeout(() => {
        dispatch({
          type: "SET",
          payload: tasks.map(t => Math.random() > 0.7 ? {...t, completed: true} : t)
        });
      }, 1500);
    }

    if(mode === "disaster") {
      setTimeout(() => {
        const duplicated = tasks.flatMap(t =>
          Math.random() > 0.6 ? [t, {...t, id: Date.now()+Math.random()}] : [t]
        );
        dispatch({ type: "SET", payload: duplicated });
      }, 1500);
    }

  }, [mode]);

  // Undo / Redo
  const saveHistory = (newTasks) => {
    setHistory([...history, tasks]);
    setFuture([]);
    dispatch({ type: "SET", payload: newTasks });
  };

  const undo = () => {
    if(history.length === 0) return;
    const prev = history[history.length - 1];
    setFuture([tasks, ...future]);
    setHistory(history.slice(0, -1));
    dispatch({ type: "SET", payload: prev });
  };

  const redo = () => {
    if(future.length === 0) return;
    const next = future[0];
    setHistory([...history, tasks]);
    setFuture(future.slice(1));
    dispatch({ type: "SET", payload: next });
  };

  // Add Task
  const addTask = () => {
    if(!text) return;

    const newTask = {
      id: Date.now(),
      versions: {
        optimistic: text + " (Easy Mode)",
        realistic: text,
        disaster: text + " (Hardcore Mode)"
      },
      completed: false
    };

    saveHistory([...tasks, newTask]);
    setText("");
  };

  // Drag Drop
  const onDragStart = (index) => setDragIndex(index);

  const onDrop = (index) => {
    const copy = [...tasks];
    const dragged = copy[dragIndex];
    copy.splice(dragIndex, 1);
    copy.splice(index, 0, dragged);
    saveHistory(copy);
  };

  // Snapshot
  const saveSnapshot = () => {
    setSnapshots([...snapshots, { mode, tasks }]);
  };

  const loadSnapshot = (snap) => {
    dispatch({ type: "SET", payload: snap.tasks });
  };

  return (
    <div className={`app ${mode}`}>
      <h1>ðŸŒŒ Parallel Reality Task Manager</h1>

      <h2>Reality Mode: {mode.toUpperCase()}</h2>

      <button onClick={randomReality}>Switch Reality</button>
      <button onClick={undo}>Undo</button>
      <button onClick={redo}>Redo</button>
      <button onClick={saveSnapshot}>Save Snapshot</button>

      <div>
        <input value={text} onChange={e => setText(e.target.value)} placeholder="Enter Task" />
        <button onClick={addTask}>Add Task</button>
      </div>

      <AnimatePresence>
        {tasks.map((task, index) => (
          <motion.div
            key={task.id}
            className={`task ${task.completed ? "completed" : ""}`}
            draggable
            onDragStart={() => onDragStart(index)}
            onDragOver={e => e.preventDefault()}
            onDrop={() => onDrop(index)}
            initial={{ opacity: 0, y: -20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0 }}
          >
            <div onClick={() => saveHistory(
              tasks.map(t => t.id === task.id ? {...t, completed: !t.completed} : t)
            )}>
              {task.versions[mode]}
            </div>
            <button onClick={() => saveHistory(tasks.filter(t => t.id !== task.id))}>
              Delete
            </button>
          </motion.div>
        ))}
      </AnimatePresence>

      <div className="snapshot-box">
        <h3>Reality Snapshots</h3>
        {snapshots.map((snap, i) => (
          <div key={i}>
            <button onClick={() => loadSnapshot(snap)}>
              Load Snapshot {i+1} ({snap.mode})
            </button>
          </div>
        ))}
      </div>
    </div>
  );
}

// Render
ReactDOM.createRoot(document.getElementById("root")).render(
  <RealityProvider>
    <App />
  </RealityProvider>
);

</script>
</body>
</html>
